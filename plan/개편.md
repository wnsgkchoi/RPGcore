### **리팩토링 최종 목표 및 설계도 (ver.3)**

**최종 목표:** 장비, 장비 세트, 스킬(패시브/액티브), 몬스터 스킬에서 발생하는 **모든 종류의 효과**를 하나의 통일된 '트리거-핸들러' 시스템으로 처리하여, 향후 기능 추가 및 수정이 용이한 일관되고 확장성 높은 구조를 완성한다.

그랜드 디자인에 대한 합의가 이루어졌으니, 이제 구체적인 구현 순서를 정할 차례입니다.
저는 시스템의 **'뼈대'**를 먼저 세우고, **'살'**을 붙인 뒤, 마지막으로 기존 콘텐츠를 **'이식'**하는 점진적인 방식으로 진행하는 것을 제안합니다. 이렇게 하면 각 단계마다 목표가 명확해지고, 테스트가 용이하며, 시스템이 올바르게 동작하는지 확인하면서 안정적으로 나아갈 수 있습니다.
아래는 제가 제안하는 구체적이고 상세한 구현 계획입니다.

### **RPGCore 개편 구현 계획 (Implementation Roadmap)**

#### **1단계: 핵심 기반 설계 (Core Foundation)**
*목표: 새로운 '트리거-핸들러' 시스템과 '조건부 스탯' 시스템의 가장 기본적인 데이터 구조와 관리자를 정의하고 구현합니다. 아직 실제 게임 이벤트와 연동되지는 않지만, 시스템의 뼈대를 완성하는 단계입니다.*

1.  **데이터 클래스 정의 (`/effects/` 및 `/effects/context/` 패키지)**
    * **`Effect`, `Trigger`, `EffectAction`**: YAML 구조와 1:1로 매칭되는 데이터 클래스를 정의합니다.
    * **`TriggerType`**: `ON_DEAL_DAMAGE` 등 모든 이벤트 유형을 포함하는 열거형 클래스를 완성합니다.
    * **`EventContext`**: `CombatEventContext`, `SkillCastEventContext` 등 이벤트 발생 시 정보를 전달할 `sealed interface`와 데이터 클래스들을 정의합니다.

2.  **효과 처리 방식 구분자 정의**
    * '이벤트 기반 효과'와 '조건부 스탯 효과'를 구분하기 위한 방법을 결정하고 구현합니다. YAML 파일에 `processing_type: EVENT_DRIVEN` 또는 `processing_type: CONDITIONAL_STAT` 같은 명시적인 필드를 추가하는 것이 가장 명확하고 확장성 있는 방법이 될 것입니다.
    * 이 정보를 담을 `EffectProcessingType` enum 클래스를 생성합니다.

3.  **관리자(Manager) 기본 구현**
    * **`EffectTriggerManager` 구현**:
        * 핸들러를 등록하는 `registerHandler()`
        * 효과를 등록/해제하는 `registerEffect()`, `unregisterEffect()`
        * 이벤트를 받아 효과를 실행하는 `fireTrigger()` 메소드의 기본 구조를 작성합니다. (이때, `Condition` 검사 로직은 `return true`로 고정하여 일단 넘어갑니다.)
    * **`StatManager` 수정**:
        * 플레이어의 모든 '조건부 스탯 효과' 목록을 저장할 필드를 추가합니다.
        * `getStat()` 메소드 내에서, 이 목록을 순회하며 현재 조건에 맞는 효과를 찾아 스탯을 동적으로 계산하는 로직의 **주석 처리된 프로토타입**을 작성합니다. (아직 실제 동작은 하지 않음)

4.  **기본 핸들러(Handler) 구현**
    * `EffectHandler` 인터페이스를 정의합니다.
    * 가장 간단한 핸들러 2~3개 (예: `DEBUG_MESSAGE`, `HEAL`)를 구현하여 `EffectTriggerManager`에 등록하는 예시 코드를 작성합니다. 이를 통해 핸들러 등록 및 호출 플로우가 정상 작동하는지 개념적으로 검증할 수 있습니다.

#### **2단계: 시스템 연동 및 테스트 (Integration & Testing)**
*목표: 1단계에서 만든 뼈대를 실제 게임 이벤트 및 데이터 로딩 프로세스와 연결합니다. 첫 번째 효과가 실제로 게임 내에서 동작하는 것을 확인하는 단계입니다.*

1.  **리스너(Listener) 연동**
    * `CombatListener`를 수정하여, `EntityDamageByEntityEvent`가 발생했을 때 `CombatEventContext`를 생성하고 `EffectTriggerManager.fireTrigger(TriggerType.ON_DEAL_DAMAGE, context)`를 호출하도록 구현합니다.
    * `PlayerConnectionListener`를 수정하여, 플레이어 접속 시 장비/스킬로부터 `Effect` 데이터를 로드하고, `EffectTriggerManager`와 `StatManager`에 각각 등록/전달하도록 구현합니다.

2.  **데이터 로딩 로직 수정**
    * `SkillManager`, `EquipmentManager`, `SetBonusManager`가 YAML 파일을 읽을 때, `effects` 섹션을 파싱하도록 수정합니다.
    * 앞서 정의한 `processing_type`에 따라 '이벤트 기반 효과'는 `EffectTriggerManager.registerEffect()`로 보내고, '조건부 스탯 효과'는 `PlayerData` 또는 `StatManager`가 관리하는 목록에 추가하도록 분류 로직을 구현합니다.

3.  **최초의 '이벤트 기반 효과' 구현 및 테스트**
    * 가장 간단한 효과를 하나 선정합니다. (예: "기본 공격 시 10% 확률로 '번개' 파티클 효과 발생")
    * 이 효과에 대한 YAML 파일을 작성합니다.
    * `PARTICLE` 액션을 처리할 `ParticleHandler`를 구현합니다.
    * 실제 게임 내에서 공격 시 번개가 발생하는지 테스트하고 디버깅합니다.

4.  **최초의 '조건부 스탯 효과' 구현 및 테스트**
    * 가장 간단한 조건부 스탯 효과를 선정합니다. (예: `tough_body` - 항상 방어력 10 증가)
    * `StatManager`의 `getStat()` 메소드에 구현해둔 프로토타입을 실제 코드로 완성하여, `DEFENSE` 스탯을 조회할 때 `tough_body` 효과가 있으면 10을 더해주도록 구현합니다.
    * 게임 내에서 스탯 창을 열어 방어력이 정상적으로 오르는지 테스트하고 디버깅합니다.

#### **3단계: 기존 콘텐츠 마이그레이션 (Content Migration)**
*목표: 2단계에서 검증된 패턴을 바탕으로, 기존의 모든 스킬, 아이템, 세트 효과를 새로운 시스템으로 점진적으로 전환합니다.*

1.  **핸들러 전체 구현**: `DAMAGE`, `APPLY_BUFF`, `COOLDOWN_REDUCTION` 등 기존에 존재하던 모든 종류의 효과에 대한 `EffectHandler`를 구현합니다.
2.  **조건(Condition) 파서 구현**: `EffectTriggerManager`와 `StatManager` 내부에 `Condition`을 파싱하고 평가하는 로직을 완성합니다. (예: `caster_hp_above: "50%"` 같은 조건을 해석하여 `context`의 데이터와 비교)
3.  **콘텐츠 전환 (반복 작업)**:
    * 직업별로, 또는 장비 세트별로 단위를 정합니다. (예: '이번에는 프렌지 DPS 스킬 전부 전환')
    * 해당 스킬/아이템의 기존 로직을 분석합니다.
    * 새로운 YAML 형식에 맞게 효과를 재정의합니다.
    * 게임 내에서 원래 의도대로 동작하는지 철저히 테스트합니다.
    * 이 과정을 모든 콘텐츠에 대해 반복합니다.

#### **4단계: 정리 및 최적화 (Cleanup & Optimization)**
*목표: 모든 콘텐츠 이전이 완료된 후, 더 이상 사용되지 않는 코드를 제거하고 시스템을 최종적으로 다듬습니다.*

1.  **구(舊) 시스템 코드 제거**: 마이그레이션이 완료되어 더 이상 호출되지 않는 과거의 `SkillEffectExecutor` 및 개별 핸들러 클래스 등 레거시 코드를 모두 삭제합니다.
2.  **코드 리뷰 및 리팩토링**: 전체 시스템을 다시 한번 검토하며 중복되는 코드는 없는지, 더 효율적으로 개선할 부분은 없는지 확인하고 리팩토링을 진행합니다.
3.  **최종 테스트**: 모든 기능이 정상적으로 동작하는지 종합적인 회귀 테스트(regression test)를 수행합니다.

이 계획대로 진행하는 것에 대해 어떻게 생각하시나요? 동의하신다면, **[1단계: 핵심 기반 설계]**의 첫 번째 작업인 **데이터 클래스 정의**부터 코드를 작성해 나가겠습니다.