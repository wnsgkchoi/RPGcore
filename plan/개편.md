### **리팩토링 최종 목표 및 설계도 (ver.3)**

**최종 목표:** 장비, 장비 세트, 스킬(패시브/액티브), 몬스터 스킬에서 발생하는 **모든 종류의 효과**를 하나의 통일된 '트리거-핸들러' 시스템으로 처리하여, 향후 기능 추가 및 수정이 용이한 일관되고 확장성 높은 구조를 완성한다.

---

### **1단계: 핵심 데이터 구조 정의**

새로운 효과 시스템의 뼈대가 될 데이터 타입을 정의합니다.

* **`effects` 패키지 생성:**
    * **위치:** `src/main/kotlin/org/flash/rpgcore/effects/`
    * **목적:** 새로운 효과 시스템과 관련된 모든 클래스(Enum, 데이터 클래스, 핸들러, 관리자)를 이 패키지 하위에 체계적으로 관리합니다.

* **`TriggerType.kt` 파일 생성:**
    * **내용:** 효과가 발동되는 모든 **상황(Trigger)**을 `Enum`으로 명확하게 정의합니다.
    * **포함될 Enum 값:** `ON_HIT_DEALT`, `ON_HIT_TAKEN`, `ON_SKILL_USE`, `ON_CRIT_DEALT`, `ON_LEARN_PASSIVE`, `ON_EQUIP`, `ON_UNEQUIP`, `ON_MOVE`, `ON_JUMP`, `ON_SNEAK`, `PERIODIC` 등.

* **`EffectAction.kt` 파일 생성:**
    * **내용:** 효과가 발동했을 때 수행될 **행동(Action)**의 내용(`type`과 `parameters`)을 정의하는 데이터 클래스입니다. 이는 기존의 `EffectDefinition`을 대체합니다.

* **`Effect.kt` 파일 생성:**
    * **내용:** `trigger: TriggerType`과 `action: EffectAction`을 하나로 묶어, "어떤 상황에 어떤 행동을 할지"를 정의하는 완전한 **효과(Effect)** 데이터 클래스입니다.

### **2단계: 데이터 소스(YAML) 구조 통일**

모든 장비, 세트, 스킬 YAML 파일에서 효과를 정의하는 방식을 위에서 정의한 `Effect` 데이터 구조에 맞게 통일합니다.

* **`equipment/**/*.yml` (모든 장비 파일) 수정:**
    * 기존의 `unique_effects_on_hit_dealt`, `unique_effects_on_equip` 등 여러 개로 흩어져 있던 키를 **모두 삭제**합니다.
    * 대신, `effects:` 라는 단일 리스트 키를 사용하고, 그 안에 `{ trigger: TRIGGER_TYPE, action: { type: ..., parameters: ... } }` 형식으로 모든 효과를 재정의합니다.

* **`equipment_sets.yml` (세트 효과 파일) 수정:**
    * `bonus_effects_by_tier` 내부의 효과들도 장비 파일과 동일하게 `trigger/action` 구조로 변경합니다.
    * `CRITICAL_BOOST`와 같이 이벤트 기반이 아닌 '상시 스탯 보너스' 효과는 `bonus_effects_by_tier`에서 제거하고, `bonus_stats_by_tier`로 이전하여 `StatManager`가 직접 처리하도록 데이터를 명확히 분리합니다.

* **`skills/**/*.yml` (모든 스킬 파일) 수정:**
    * **액티브 스킬:** `level_data` 내부의 `effects` 목록에 있는 모든 효과(DAMAGE, PARTICLE 등)를 `trigger: ON_SKILL_USE`로 감싸서 구조를 통일합니다.
    * **패시브 스킬:** `reflection_aura`(`ON_HIT_TAKEN`), `bloody_smell`(`ON_HIT_TAKEN`) 등 각 패시브의 실제 발동 조건에 맞는 `TriggerType`을 `trigger` 값으로 명시합니다.
    * `tough_body`, `windflow`처럼 상시 스탯 계산에 관여하는 패시브는 `ON_LEARN_PASSIVE` 트리거를 사용하도록 지정합니다. 이는 해당 효과가 '이벤트'가 아닌 '조건부 스탯 계산' 대상임을 시스템에 알려주는 마커 역할을 합니다.

### **3단계: 코드 구현 및 리팩토링**

YAML 구조 통일이 완료된 후, 실제 시스템을 코드로 구현합니다.

* **`EffectHandler.kt` 인터페이스 수정:**
    * `execute` 함수의 첫 번째 인자를 `player: Player`가 아닌 **`caster: LivingEntity`** 로 변경합니다. 이를 통해 플레이어뿐만 아니라 몬스터도 스킬 시전의 주체가 될 수 있도록 시스템을 일반화합니다.

* **개별 `EffectHandler` 클래스 전체 구현:**
    * `effects/handlers/` 패키지 내부에, YAML에 정의된 **모든 `action` 타입에 대해 1:1로 대응하는 핸들러 클래스 파일을 전부 생성**합니다. (예: `DoubleStrikeHandler.kt`, `TauntHandler.kt` 등)
    * 각 핸들러는 `EffectHandler` 인터페이스를 구현하며, `execute` 메소드 안에 해당 효과의 실제 실행 로직을 담습니다.

* **`EffectTriggerManager.kt` 구현:**
    * `registerHandlers()` 함수 내부에 위에서 만든 **모든 핸들러 객체를 등록**하는 코드를 작성합니다.
    * `fire(trigger: TriggerType, caster: LivingEntity, context: Any?)` 함수를 구현합니다. 이 함수는 다음 로직을 수행합니다:
        1.  `caster`의 장비, 세트 효과, 학습한 패시브 스킬 목록을 모두 가져옵니다.
        2.  이 목록에서 현재 발생한 `trigger`와 일치하는 `Effect`들만 필터링합니다.
        3.  필터링된 각 `Effect`의 `action.type`에 맞는 핸들러를 찾아 `execute` 메소드를 호출합니다.

* **`SkillManager.kt`, `SkillEffectExecutor.kt`, `MonsterSkillManager.kt` 수정:**
    * `RPGSkillData` 데이터 클래스의 `effects` 필드 타입을 새로운 `List<Effect>`로 변경합니다.
    * `SkillManager`의 `loadSkillFromFile` 함수가 새로운 YAML 구조를 파싱하도록 수정합니다.
    * `SkillEffectExecutor`의 `execute` 메소드가 `LivingEntity`를 시전자로 받을 수 있도록 수정하고, 내부의 복잡한 `when` 분기문을 제거합니다. 대신, `ON_SKILL_USE` 트리거를 `EffectTriggerManager`로 보내는 역할만 하도록 단순화합니다.
    * `MonsterSkillManager`는 더 이상 직접 효과를 처리하지 않고, `SkillEffectExecutor.execute(monster, ...)`를 호출하도록 변경합니다.

* **모든 `Listener` 파일 리팩토링:**
    * `CombatListener`, `SkillKeyListener` 등 모든 리스너에서 기존에 직접 처리하던 효과 관련 로직(예: 더블 스트라이크 확률 계산)을 **완전히 삭제**합니다.
    * 대신 "공격이 발생했다", "스킬 키가 눌렸다"와 같은 이벤트가 발생했음을 `EffectTriggerManager.fire()`를 통해 중앙 관리자에게 **알리는 역할만** 하도록 코드를 최소화합니다.

* **`StatManager.kt` 수정:**
    * `getFinalStatValue` 함수를 수정하여, `ON_LEARN_PASSIVE` 같은 트리거를 가진 조건부 스탯 효과(`tough_body`, `windflow` 등)를 직접 계산하도록 로직을 추가합니다. `StatManager`는 스탯 계산이 필요할 때마다 플레이어의 효과 목록을 확인하여 해당 조건에 맞는 스탯 보너스를 최종 값에 합산합니다.